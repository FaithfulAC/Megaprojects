getgenv().europa = {
	Players = game:GetService("Players"),
	LocalPlayer = game:GetService("Players").LocalPlayer or game:GetService("Players"):GetPropertyChangedSignal("LocalPlayer"):Wait(),
	gs = function(classname: string)
		return game:GetService(classname)
	end,
	getcs = function()
		return game:GetService("CoreGui").RobloxGui:FindFirstChild("Folder") or Instance.new("Folder", game:GetService("CoreGui").RobloxGui)
	end,
	checkvar = function(method: string, str: string): boolean
		method = method:gsub("^%u", string.lower)
		str = str:gsub("^%u", string.lower)
		return method == str or (method:find(str) and method:sub(1, str:len()+1) == str .. "\000")
	end,
	getrh = function()
		--[[if Krnl then
			if #getconnections(game.DescendantAdded) > 0 then
				return game:GetService("CoreGui").RobloxGui:FindFirstChild("Folder") or Instance.new("Folder", game:GetService("CoreGui").RobloxGui)
			else
				return gethui()
			end
		else]]if gethui and gethui() ~= game:GetService("CoreGui") then -- [[ (._.) ]]
			return gethui()
		else
			return game:GetService("CoreGui").RobloxGui:FindFirstChild("Folder") or Instance.new("Folder", game:GetService("CoreGui").RobloxGui)
		end
	end,
	hookggoap = if not (hookmetamethod and hookfunction) then nil else function()
		local pgui = game:GetService("Players").LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
		
		local gh1;gh1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == pgui and method == "getGuiObjectsAtPosition" then
				return 1
			end
			return gh1(self,...)
		end)
		local gh2;gh2=hookfunction(pgui.GetGuiObjectsAtPosition, function(arg,...)
			if not checkcaller() and arg == pgui then
				return 1
			end
			return gh1(arg,...)
		end)
	end,
	hookggoap2 = if not (hookmetamethod and hookfunction) then nil else function()
		local guis = game:GetService("GuiService")
		for i, v in next, getconnections(guis.MenuClosed) do
			v:Disable()
		end
		local h;h=hookmetamethod(game,"__index", function(self,arg,...)
			local _arg = if type(arg) == "string" then arg:gsub("^%u", string.upper) else "" -- previously detected by metatable __namecall
			if not checkcaller() and self == guis and _arg == "MenuIsOpen" or _arg:sub(1, 11) == "MenuIsOpen\0" then
				return true
			end
			return h(self,arg,...)
		end)
	end,
	hookgcinfo = if not hookfunction then nil else function()
		local mini = 800
		local max = 1200

		local num = if gcinfo() < max and gcinfo() > mini then math.random(mini - 18, mini + 24) else gcinfo()
		
		if gcinfo() > max then max = gcinfo(); mini = max - math.floor(math.random(3, 6)*100) end
		if gcinfo() < mini then mini = gcinfo(); max = mini + math.floor(math.random(3, 6)*100) end
		
		task.spawn(function()
			while game:GetService("RunService").RenderStepped:Wait() do
				local int = math.random(4, 8)
				if num < max - math.random(10,30) then num = math.floor(num+int) game.ItemChanged:Wait() num += math.random(1,2) else
					num = math.floor(math.random(mini - 18, mini + 24))
					game.ItemChanged:Wait()
					num += 1
				end
			end
		end)
		local h;h=hookfunction(getrenv().gcinfo, function(...)
			if not checkcaller() then return num end
			return h(...)
		end)
		local h2;h2=hookfunction(getrenv().collectgarbage, function(cnt,...)
			if not checkcaller() and type(cnt) == "string" and (cnt == "count" or cnt:sub(1,6) == "count\0") then
				return num
			end
			return h2(cnt,...)
		end)
	end,
	hookmem = if not (hookmetamethod and hookfunction) then nil else function()
		local stats = game:GetService("Stats")
		local ret = stats:GetTotalMemoryUsageMb()
		task.spawn(function()
			while game:GetService("RunService").RenderStepped:Wait() do
				ret += math.random(-2,2)/32 - math.random(-.5,.5)/1500
				task.wait(math.random(1,3)/90)
			end
		end)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == stats and method == "getTotalMemoryUsageMb" then
				return ret
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(stats.GetTotalMemoryUsageMb, function(a,...)
			if not checkcaller() and a == stats then
				return ret
			end
			return h2(a,...)
		end)
	end,
	getmem = function()
		return game:GetService("Stats"):GetTotalMemoryUsageMb()
	end,
	getmemtag = function(enum: EnumItem)
		return game:GetService("Stats"):GetMemoryUsageMbForTag(enum)
	end,
	setmeminflation = function(bool: boolean)
		local memconn = getgenv().meminflateconn
		if bool == false then
			if memconn then memconn:Disconnect() getgenv().meminflateconn = nil end
			return
		end
		getgenv().meminflateconn = game:GetService("RunService").Stepped:Connect(function()
			for i = 1, 100 do
				local part = Instance.new("Part")
				part.Parent = workspace
				
				local orient = Vector3.new(math.random(1, 360000)/100, math.random(1, 360000)/100, math.random(1, 360000)/100)
				part.Size = Vector3.new(2048,2048,2048)
				part.Orientation = orient
				part.Position = Vector3.new(9e9,9e9,9e9)
				part.Anchored = true
				part:Destroy()
			end
		end)
	end,
	setmemtaginflation = function(bool: boolean, enum: Enum) -- only supports script and gui lol (default is gui)
		local scrfunc = getgenv().memtagscriptfunc
		local guifunc = getgenv().memtagguifunc
		if bool == false then
			if scrfunc then scrfunc:Disconnect() getgenv().memtagscriptfunc = nil end
			if guifunc then guifunc:Disconnect() getgenv().memtagguifunc = nil end
			return
		end
		if enum == Enum.DeveloperMemoryTag.Script or tostring(enum):find("s") then
			if scrfunc then return end
			getgenv().memtagscriptfunc =  game:GetService("RunService").Heartbeat:Connect(function()
				task.spawn(function(...) -- doing random stuff to increase script activity
					for i = 1, 100 do
						local a = Instance.new("Script")
						a.Enabled = false
						a.Disabled = false
						a:Destroy()
					end
					for i, v in pairs(workspace:GetDescendants()) do pcall(v.SetAttribute) end
				end)
			end)
		else -- gui or default (gui)
			if guifunc then return end
			getgenv().memtagguifunc = game:GetService("RunService").Heartbeat:Connect(function()
				for i = 1, 100 do
					local frame = Instance.new("Frame", game:GetService("CoreGui").RobloxGui)
					frame.Size = UDim2.new(20,0,20,0)
					frame.Position = UDim2.new(50,0,50,0)
					task.spawn(function()
						task.wait(1)
						frame:Destroy()
					end)
				end
			end)
		end
	end,
	isalive = isalive or function(): boolean -- thank u electron for the idea :))))))))))
		return game:GetService("Stats").DataSendKbps ~= 0 and game:GetService("Stats").DataReceiveKbps ~= 0
	end,
	setgcinflation = function(bool: boolean)
		local tbl = getgenv().gcinflationtable
		if bool == false then
			if tbl then table.clear(tbl) getgenv().gcinflationtable = nil end
			return
		end
		getgenv().gcinflationtable = {}
		task.spawn(function()
			while getgenv().gcinflationtable do
				for i = 1, math.random(100,200) do
					table.insert(getgenv().gcinflationtable or {}, (function()
						local str = ""
						for i = 1, math.random(10,20) do
							str = str .. string.char(math.random(32, 126))
						end
						return str
					end)())
					task.wait()
				end
				if math.random() > 0.7 then
					table.clear(getgenv().gcinflationtable or {})
				end
				task.wait()
			end
		end)
	end,
	disconn = function(conn)
		for i, v in next, getconnections(conn) do
			v:Disable()
		end
	end,
	securedisconn = if not (hookmetamethod and hookfunction) then nil else function(conn, waithook: boolean) -- basically a hook lol
		local temp = game:GetPropertyChangedSignal("Name"):Connect(function()end)
		local h;h=hookmetamethod(c,"__index", function(self,b,...)
			if not checkcaller() and self == conn and b == "Connected" then
				return if waithook then wait(9e9) else true
			end
			return h(self,b,...)
		end)
		for i, v in next, getconnections(conn) do
			v:Disable()
		end
	end,
	clientran = function(scr: Instance)
		return scr.ClassName == "LocalScript" or (scr.ClassName == "Script" and scr.RunContext == Enum.RunContext.Client)
	end,
	serverran = function(scr: Instance)
		return scr.ClassName == "Script" and scr.RunContext ~= Enum.RunContext.Client
	end,
	antihttp = function(grabArgs: boolean)
		if not grabArgs then
			getgenv().httprequest = nil
		else
			getgenv().httprequest = function(tbl)
				warn("httprequest was triggered! Here are the arguments:")
				
				if type(tbl) == "table" then
					for i, v in pairs(tbl) do
						print(i, v)
					end
				else
					print(tbl)
				end
				
				warn("End of arguments")
			end
		end
	end,
	antiweaktable = if not getgc then nil else function()
		for i, v in getgc(true) do
			if type(v) == "table" and getmetatable(v) and type(getmetatable(v)) == "table" and (rawget(getmetatable(v), "__mode") == "v" or rawget(getmetatable(v), "__mode") == "kv") then
				local newmeta = getmetatable(v)
				if table.isfrozen(v) or table.isfrozen(newmeta) then continue end
				rawset(newmeta,"__mode",nil)
				setmetatable(v, newmeta)
				v = {}
			end
		end
	end,
	antiweaktable2 = if not hookfunction then nil else function(checkMetaAmnt: boolean)
		local h;h=hookfunction(getrenv().setmetatable, function(tbl1, tbl2, ...)
			if not checkcaller() and #tbl1 > 0 and (if checkMetaAmnt then #tbl2 == 1 else true) then
				local isMode = false
				local var = nil
				for i, v in pairs(tbl2) do -- Member table.foreachi is deprecated :(
					if i == "__mode" and (v == "v" or v == "kv") then var = v; isMode = true end
				end
				if isMode then
					local tbl = {__mode = var}
					local target = {}
					for i = 1, #tbl1 do
						table.insert(target, newproxy(true))
					end
					return setmetatable(target, tbl)
				end
			end
			return h(tbl1, tbl2, ...)
		end)
		for i, v in getgc(true) do
			if type(v) == "table" and getmetatable(v) and type(getmetatable(v)) == "table" and (rawget(getmetatable(v), "__mode") == "v" or rawget(getmetatable(v), "__mode") == "kv") then
				if table.isfrozen(v) then continue end
				table.clear(v)
			end
		end
	end,
	antitostring = if not getgc then nil else function()
		for i, v in getgc(true) do
			if type(v) == "table" and getmetatable(v) and type(getmetatable(v)) == "table" and getmetatable(v)["__tostring"] then
				local newmeta = getmetatable(v)
				if table.isfrozen(v) or table.isfrozen(newmeta) then continue end
				newmeta.__tostring = nil
				setmetatable(v, newmeta)
			end
		end
	end,
	getscripts = if not getinstances then nil else function()
		local tbl = {}
		for i, v in getinstances() do
			if (pcall(v.IsA, v, "Instance")) and v:IsA("LocalScript") or v:IsA("ModuleScript") or v:IsA("Script") then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	getrems = if not getinstances then nil else function()
		local tbl = {}
		for i, v in getinstances() do
			if (pcall(v.IsA, v, "Instance")) and v:IsA("RemoteEvent") then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	grabargs = if not (hookmetamethod and hookfunction) then nil else function(rem: RemoteEvent) -- local a = {grabargs(rem)}
		local args = nil
		local h;h=hookfunction(rem.FireServer, function(...)
			args = {...}
			return h(...)
		end)
		local h2;h2=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.upper)
			if self == rem and method == "FireServer" then
				args = {...}
			end
			return h2(self,...)
		end)
		while args == nil and task.wait() do end
		h=hookfunction(rem.FireServer, function(...) return h(...) end)
		h2=hookmetamethod(game,"__namecall", function(self,...) return h2(self,...) end)
		return unpack(args)
	end,
	gettables = if not getgc then nil else function()
		local tbl = {} -- lol
		for i, v in getgc(true) do
			if type(v) == "table" then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	getmetatables = if not getgc then nil else function()
		local tbl = {}
		for i, v in getgc(true) do
			if type(v) == "table" and getmetatable(v) then
				table.insert(tbl, getmetatable(v))
			end
		end
		return tbl
	end,
	getfunctions = if not getgc then nil else function()
		local tbl = {}
		for i, v in getgc() do
			if type(v) == "function" then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	getlfunctions = if not (getgc and islclosure) then nil else function()
		local tbl = {}
		for i, v in getgc() do
			if type(v) == "function" and islclosure(v) then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	getcfunctions = if not (getgc and iscclosure) then nil else function()
		local tbl = {}
		for i, v in getgc() do
			if type(v) == "function" and iscclosure(v) then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	breakjoints = function()
		return game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"):BreakJoints()
	end,
	isnil = function(a: Instance)
		return a.Parent == nil
	end,
	antikick = if not (hookmetamethod and hookfunction) then nil else function()
		local plr = game:GetService("Players").LocalPlayer
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			if not checkcaller() and self == plr and getnamecallmethod():lower() == "kick" then
				return wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(game:GetService("Players").LocalPlayer.Kick, function(a,...)
			if not checkcaller() and a == plr then
				return wait(9e9)
			end
			return h2(a,...)
		end)
	end,
	removehooks = function(duration: number)
		task.spawn(function()
			local hf, hmm = getgenv().hookfunction, getgenv().hookmetamethod
			getgenv().hookfunction = function()end
			getgenv().hookmetamethod = function()end
			task.wait(duration or 2)
			getgenv().hookfunction = hf
			getgenv().hookmetamethod = hmm
		end)
	end,
	anticrash = function()
		return game:GetService("ScriptContext"):SetTimeout(1)
	end,
	hookfs = if not (hookmetamethod and hookfunction) then nil else function(rem: RemoteEvent)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == rem and method == "fireServer" then
				return wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(rem.FireServer, function(a,...)
			if not checkcaller() and a == rem then
				return wait(9e9)
			end
			return h2(a,...)
		end)
	end,
	hookis = if not (hookmetamethod and hookfunction) then nil else function(evn: RemoteFunction)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == evn and method == "invokeServer" then
				return wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(evn.InvokeServer, function(a,...)
			if not checkcaller() and a == evn then
				return wait(9e9)
			end
			return h2(a,...)
		end)
	end,
	ls = function(url: string)
		return loadstring(game:HttpGet(url))()
	end,
	hookinscount = if not (hookmetamethod and hookfunction) then nil else function()
		local stats = game:GetService("Stats")
		local org = stats.InstanceCount
		task.spawn(function()
			while task.wait(.01) do
				org += math.random(-100, 101)
			end
		end)
		local h1;h1=hookmetamethod(game,"__index", function(self,arg,...)
			if not checkcaller() and self == stats and type(arg) == "string" and (arg == "InstanceCount" or arg:sub(1,14) == "InstanceCount\0" or (not stats:FindFirstChild("instanceCount") and (arg == "instanceCount" or arg:sub(1,14) == "instanceCount\0"))) then
				return org
			end
			return h1(self,arg,...)
		end)
	end,
	hookgs = if not (hookmetamethod and hookfunction) then nil else function(name: string, objtoreturn: Instance)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == game and method == "getService" then
				return objtoreturn or wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(game.GetService, function(a,b,...)
			if not checkcaller() and a == game and b == name then
				return objtoreturn or wait(9e9)
			end
			return h2(a,b,...)
		end)
	end,
	waithookfunc = if not hookfunction then nil else function(fnc)
		local h;h=hookfunction(fnc, function(...)
			if not checkcaller() then
				return wait(9e9)
			end	
			return h(...)
		end)
	end,
	antibodycheck = function()
		local char = game:GetService("Players").LocalPlayer.Character
		local root, torso do
			if char then root = char:FindFirstChild("HumanoidRootPart") torso = char:FindFirstChild("Torso") end
		end
		for i, v in next, getconnections(char.DescendantAdded) do
			v:Disable()
		end
		local function dothing(obj)
			for i, v in next, getconnections(obj.ChildAdded) do
				v:Disable()
			end
			for i, v in next, getconnections(obj.DescendantAdded) do
				v:Disable()
			end
			for i, v in next, getconnections(obj.Changed) do
				v:Disable()
			end
		end
		if root then dothing(root) end
		if torso then dothing(torso) end
	end,
	antihumcheck = function() -- can interfere with looping walkspeed
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		for i, v in next, getconnections(hum.Changed) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("WalkSpeed")) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("JumpPower")) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("HipHeight")) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("JumpHeight")) do
			v:Disable()
		end
	end,
	setnoclip = function(bool: boolean)
		if not bool then
			if noclipconn then
				noclipconn:Disconnect()
			end
			getgenv().noclipconn = nil
			return
		end
		getgenv().noclipconn = noclipconn or game:GetService("RunService").Stepped:Connect(function()
			pcall(function()
				for i, v in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
					if v:IsA("BasePart") then v.CanCollide = false end
				end
			end)
		end)
	end,
	setws = function(int: number, loopHum: boolean)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum and loopHum then
			if getgenv().wsloop then
				getgenv().wsloop:Disconnect()
			end
			getgenv().wsloop = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
				hum.WalkSpeed = int
			end)
		end
		hum.WalkSpeed = int
	end,
	setjp = function(int: number, loopHum: boolean)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum and loopHum then
			if getgenv().jploop then
				getgenv().jploop:Disconnect()
			end
			getgenv().jploop = hum:GetPropertyChangedSignal("JumpPower"):Connect(function()
				hum.JumpPower = int
			end)
		end
		hum.JumpPower = int
	end,
	setjpenabled = function(bool: boolean)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum then hum.UseJumpPower = bool end
	end,
	sethh = function(int: number)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum then hum.HipHeight = int end
	end,
	setgrav = function(int: number)
		workspace.Gravity = int
	end,
	loadiy = function()
		return loadstring(game:HttpGet(('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'),true))()
	end,
	loadcmdx = function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source", true))()
	end,
	loadsecuredex = function() -- dark dex v3 is broken on fluxus so i decided to use babyhamsta's instead
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/BypassedDarkDexV3.lua", true))()
	end,
	loaddex = function() -- prevents hooks from being used in secure dex so it's basically dex v3
		local hf, hmm = getgenv().hookfunction, getgenv().hookmetamethod
		getgenv().hookfunction = function()end
		getgenv().hookmetamethod = function()end
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/BypassedDarkDexV3.lua", true))()
		task.wait(.5)
		getgenv().hookfunction = hf
		getgenv().hookmetamethod = hmm
	end,
	loadss = function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/78n/SimpleSpy/main/SimpleSpySource.lua"))()
	end,
	loadv4 = function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/NewMainScript.lua", true))()
	end,
	rj = function()
		game:GetService("TeleportService"):Teleport(game.PlaceId)
	end,
}
europa["getservice"] = europa.gs
europa["getcoresecure"] = europa.getcs
europa["checkvariable"] = europa.checkvar
europa["getrealhidden"], europa["getrhui"] = europa.getrh, europa.getrh
europa["getmemory"] = europa.getmem
europa["getmemorytag"] = europa.getmemtag
europa["hookmemory"] = europa.hookmem
europa["getremotes"] = europa.getrems
europa["getluafunctions"] = europa.getlfunctions
europa["isnilinstance"] = europa.isnil
europa["setmemoryinflation"] = europa.setmeminflation
europa["setmemorytaginflation"] = europa.setmemtaginflation
europa["disconnect"] = europa.disconn
europa["securedisconnect"] = europa.securedisconn
europa["hookfireserver"] = europa.hookfs
europa["hookinvokeserver"] = europa.hookis
europa["hookgetservice"] = europa.hookgs
europa["hookinstancecount"] = europa.hookinscount
europa["waithookfunction"] = europa.waithookfunc
europa["antihumanoidcheck"] = europa.antihumcheck
europa["setwalkspeed"] = europa.setws
europa["setjumppower"] = europa.setjp
europa["sethipheight"] = europa.sethh
europa["setmaxslopeangle"] = europa.setmsa
europa["setgravity"] = europa.setgrav
europa["setjumppowerenabled"] = europa.setjpenabled
europa["loadinfiniteyield"] = europa.loadiy
europa["loadsimplespy"] = europa.loadss
europa["loadvapev4"] = europa.loadv4
europa["rejoin"] = europa.rj

for i, v in europa do
	getgenv()[i] = v
end
