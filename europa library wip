getgenv().europa = {
	Players = game:GetService("Players"),
	LocalPlayer = game:GetService("Players").LocalPlayer,
	Stats = game:GetService("Stats"),
	ReplicatedFirst = game:GetService("ReplicatedFirst"),
	getcs = function()
		return game:GetService("CoreGui").RobloxGui:FindFirstChild("Folder") or Instance.new("Folder", game:GetService("CoreGui").RobloxGui)
	end,
	checkvar = function(method, str)
		method = method:gsub("^%u", string.lower)
		str = str:gsub("^%u", string.lower)
		return method == str or (method:find(str) and method:sub(1, str:len()+1) == str .. "\000")
	end,
	getrh = function()
		if Krnl then
			if #getconnections(game.DescendantAdded) > 0 then
				return game:GetService("CoreGui").RobloxGui:FindFirstChild("Folder") or Instance.new("Folder", game:GetService("CoreGui").RobloxGui)
			else
				return gethui()
			end
		elseif gethui and gethui() ~= game:GetService("CoreGui") then -- [[ (._.) ]]
			return gethui()
		else
			return game:GetService("CoreGui").RobloxGui:FindFirstChild("Folder") or Instance.new("Folder", game:GetService("CoreGui").RobloxGui)
		end
	end,
	hookggoap = if not (hookmetamethod and hookfunction) then nil else function()
		local pgui = game:GetService("Players").LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
		
		local gh1;gh1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == pgui and method == "getGuiObjectsAtPosition" then
				return 1
			end
			return gh1(self,...)
		end)
		local gh2;gh2=hookfunction(pgui.GetGuiObjectsAtPosition, function(arg,...)
			if not checkcaller() and arg == pgui then
				return 1
			end
			return gh1(arg,...)
		end)
	end,
	hookggoap2 = if not (hookmetamethod and hookfunction) then nil else function()
		local guis = game:GetService("GuiService")
		for i, v in next, getconnections(guis.MenuClosed) do
			v:Disable()
		end
		local h;h=hookmetamethod(game,"__index", function(self,arg,...)
			local _arg = arg:gsub("^%u", string.upper)
			_arg:gsub("\000", "")
			if not checkcaller() and self == guis and _arg == "MenuIsOpen" then
				return true
			end
			return h(self,arg,...)
		end)
	end,
	hookgcinfo = if not hookfunction then nil else function()
		local mini = 500
		local max = 1200

		local num = if gcinfo() < max and gcinfo() > mini then math.random(mini - 18, mini + 24) else gcinfo()
		
		task.spawn(function()
			for i = 1, 15 do
				if gcinfo() > max then max = gcinfo(); mini = max - math.floor(math.random(4, 6)*100) end
				if gcinfo() < mini then mini = gcinfo(); max = mini + math.floor(math.random(4, 6)*100) end
				task.wait()
			end
		end)
		
		task.spawn(function()
			while game:GetService("RunService").RenderStepped:Wait() do
				local int = math.random(4, 8)
				if num < max - math.random(10,30) then num = math.floor(num+int) game.ItemChanged:Wait() num += math.random(1,2) else
					num = math.floor(math.random(mini - 18, mini + 24))
					game.ItemChanged:Wait()
					num += 1
				end
			end
		end)
		local h;h=hookfunction(getrenv().gcinfo, function(...)
			if not checkcaller() then return num end
			return h(...)
		end)
		local h2;h2=hookfunction(getrenv().collectgarbage, function(cnt,...)
			if not checkcaller() and type(cnt) == "string" and (cnt == "count" or cnt:sub(1,6) == "count\000") then
				return num
			end
			return h2(cnt,...)
		end)
	end,
	hookmem = if not (hookmetamethod and hookfunction) then nil else function()
		local stats = game:GetService("Stats")
		local ret = stats:GetTotalMemoryUsageMb()
		task.spawn(function()
			while game:GetService("RunService").RenderStepped:Wait() do
				ret += math.random(-2,2)/32 - math.random(-.5,.5)/1500
				task.wait(math.random(1,3)/90)
			end
		end)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == stats and method == "getTotalMemoryUsageMb" then
				return ret
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(stats.GetTotalMemoryUsageMb, function(a,...)
			if not checkcaller() and a == stats then
				return ret
			end
			return h2(a,...)
		end)
	end,
	getmem = function()
		return game:GetService("Stats"):GetTotalMemoryUsageMb()
	end,
	getmemtag = function(enum)
		game:GetService("Stats"):GetMemoryUsageMbForTag(enum)
	end,
	setmeminflation = function(bool)
		local memconn = getgenv().meminflateconn
		if bool == false then
			if memconn then memconn:Disconnect() getgenv().meminflateconn = nil end
			return
		end
		getgenv().meminflateconn = game:GetService("RunService").Stepped:Connect(function()
			for i = 1, 100 do
				local part = Instance.new("Part")
				part.Parent = workspace
				
				local orient = Vector3.new(math.random(1, 360000)/100, math.random(1, 360000)/100, math.random(1, 360000)/100)
				part.Size = Vector3.new(2048,2048,2048)
				part.Orientation = orient
				part.Position = Vector3.new(9e9,9e9,9e9)
				part.Anchored = true
				part:Destroy()
			end
		end)
	end,
	setmemtaginflation = function(bool, enum) -- only supports script and gui lol (default is gui)
		local scrfunc = getgenv().memtagscriptfunc
		local guifunc = getgenv().memtagguifunc
		if bool == false then
			if scrfunc then scrfunc:Disconnect() getgenv().memtagscriptfunc = nil end
			if guifunc then guifunc:Disconnect() getgenv().memtagguifunc = nil end
			return
		end
		if enum == Enum.DeveloperMemoryTag.Script or tostring(Enum):find("s") then
			if scrfunc then return end
			getgenv().memtagscriptfunc =  game:GetService("RunService").Heartbeat:Connect(function()
				task.spawn(function(...) -- doing random stuff to increase script activity
					for i = 1, 100 do
						local a = Instance.new("Script")
						a.Enabled = false
						a.Disabled = false
						a:Destroy()
					end
					for i, v in pairs(workspace:GetDescendants()) do pcall(v.SetAttribute) end
				end)
			end)
		else -- gui or default (gui)
			if guifunc then return end
			getgenv().memtagguifunc = game:GetService("RunService").Heartbeat:Connect(function()
				for i = 1, 10 do
					local frame = Instance.new("Frame", game:GetService("CoreGui").RobloxGui)
					frame.Size = UDim2.new(2,0,2,0)
					frame.Position = UDim2.new(5,0,5,0)
					task.spawn(function()
						task.wait(1)
						frame:Destroy()
					end)
				end
			end)
		end
	end,
	setgcinflation = function(bool)
		local tbl = getgenv().gcinflationtable
		if bool == false then
			if tbl then getgenv().gcinflationtable = nil end
			return
		end
		getgenv().gcinflationtable = {}
		task.spawn(function()
			while getgenv().gcinflationtable do
				for i = 1, math.random(100,200) do
					table.insert(getgenv().gcinflationtable or {}, (function()
						local str = ""
						for i = 1, math.random(10,20) do
							str = str .. string.char(math.random(32, 126))
						end
						return str
					end)())
					task.wait()
				end
				table.clear(getgenv().gcinflationtable or {})
				task.wait()
			end
		end)
	end,
	disconn = function(conn)
		for i, v in next, getconnections(conn) do
			v:Disable()
		end
	end,
	securedisconn = if not (hookmetamethod and hookfunction) then nil else function(conn) -- basically a hook lol
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			if not checkcaller() and self == conn and (getnamecallmethod():lower() == "wait" or getnamecallmethod():lower() == "connect") then
				return wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(conn.Wait, function(a,...)
			if not checkcaller() and a == conn then
				return wait(9e9)
			end
			return h2(a,...)
		end)	
		local h3;h3=hookfunction(conn.Connect, function(a,b,...)
			if not checkcaller() and a == conn and type(b) == "function" then
				return wait(9e9)
			end
			return h2(a,b,...)
		end)	
	end,
	antiweaktable = if not getgc then nil else function()
		for i, v in getgc(true) do
			if type(v) == "table" and getmetatable(v) and getmetatable(v)["__mode"] == "v" then
				local newmeta = getmetatable(v)
				newmeta.__mode = nil
				setmetatable(v, newmeta)
				if table.find(v, {}) or table.find(v, game:GetService("CoreGui")) then
					v = {}
					setmetatable(v, {
						__index = function()
							return wait(9e9)
						end,
						__newindex = function()
							return wait(9e9)
						end
					})
				end
			end
		end
	end,
	antitostring = if not getgc then nil else function()
		for i, v in getgc(true) do
			if type(v) == "table" and getmetatable(v) and getmetatable(v)["__tostring"] then
				local newmeta = getmetatable(v)
				newmeta.__tostring = nil
				setmetatable(v, newmeta)
			end
		end
	end,
	getscripts = if not getinstances then nil else function()
		local tbl = {}
		for i, v in getinstances() do
			if v:IsA("LocalScript") or v:IsA("ModuleScript") or v:IsA("Script") then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	getrems = if not getinstances then nil else function()
		local tbl = {}
		for i, v in getinstances() do
			if v:IsA("RemoteEvent") then
				table.insert(tbl, v)
			end
		end
		return tbl
	end,
	grabargs = if not (hookmetamethod and hookfunction) then nil else function(rem) -- local a = {grabargs(rem)}
		local args = nil
		local h;h=hookfunction(rem.FireServer, function(...)
			args = {...}
			return h(...)
		end)
		local h2;h2=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.upper)
			if self == rem and method == "FireServer" then
				args = {...}
			end
			return h3(self,...)
		end)
		while args == nil and task.wait() do end
		h=hookfunction(rem.FireServer, function(...) return h(...) end)
		h2=hookmetamethod(game,"__namecall", function(self,...) return h3(self,...) end)
		return unpack(args)
	end,
	isnil = function(a)
		return a.Parent == nil
	end,
	antikick = if not (hookmetamethod and hookfunction) then nil else function()
		local plr = game:GetService("Players").LocalPlayer
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			if not checkcaller() and self == plr and getnamecallmethod():lower() == "kick" then
				return wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(game:GetService("Players").LocalPlayer.Kick, function(a,...)
			if not checkcaller() and a == plr then
				return wait(9e9)
			end
			return h2(a,...)
		end)
	end,
	anticrash = function()
		return game:GetService("ScriptContext"):SetTimeout(1)
	end,
	hookfs = if not (hookmetamethod and hookfunction) then nil else function(rem)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == rem and method == "fireServer" then
				return wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(rem.FireServer, function(a,...)
			if not checkcaller() and a == rem then
				return wait(9e9)
			end
			return h2(a,...)
		end)
	end,
	hookis = if not (hookmetamethod and hookfunction) then nil else function(evn)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == evn and method == "invokeServer" then
				return wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(evn.InvokeServer, function(a,...)
			if not checkcaller() and a == evn then
				return wait(9e9)
			end
			return h2(a,...)
		end)
	end,
	ls = function(url)
		return loadstring(game:HttpGet(url))()
	end,
	hookinscount = if not (hookmetamethod and hookfunction) then nil else function()
		local stats = game:GetService("Stats")
		local org = stats.InstanceCount
		task.spawn(function()
			while task.wait(.01) do
				org += math.random(-5, 6)
			end
		end)
		local h1;h1=hookmetamethod(game,"__index", function(self,arg,...)
			if not checkcaller() and self == stats and (arg == "InstanceCount" or arg:sub(1,14) == "InstanceCount\000") then
				return org
			end
			return h1(self,arg,...)
		end)
	end,
	hookgs = if not (hookmetamethod and hookfunction) then nil else function(name, objtoreturn)
		local h1;h1=hookmetamethod(game,"__namecall", function(self,...)
			local method = getnamecallmethod():gsub("^%u", string.lower)
			if not checkcaller() and self == game and method == "getService" then
				return objtoreturn or wait(9e9)
			end
			return h1(self,...)
		end)
		local h2;h2=hookfunction(game.GetService, function(a,b,...)
			if not checkcaller() and a == game and b == name then
				return objtoreturn or wait(9e9)
			end
			return h2(a,b,...)
		end)
	end,
	waithookfunc = if not hookfunction then nil else function(fnc)
		local h;h=hookfunction(fnc, function(...)
			if not checkcaller() then
				return wait(9e9)
			end	
			return h(...)
		end)
	end,
	hookfunc = if not hookfunction then nil else function(fnc, valtoreturn)
		local h;h=hookfunction(fnc, function(...)
			if not checkcaller() then
				return valtoreturn
			end
			return h(...)
		end)
	end,
	antibodycheck = function()
		local char = game:GetService("Players").LocalPlayer.Character
		local root, torso do
			if char then root = char:FindFirstChild("HumanoidRootPart") torso = char:FindFirstChild("Torso") end
		end
		for i, v in next, getconnections(char.DescendantAdded) do
			v:Disable()
		end
		local function dothing(obj)
			for i, v in next, getconnections(obj.ChildAdded) do
				v:Disable()
			end
			for i, v in next, getconnections(obj.DescendantAdded) do
				v:Disable()
			end
			for i, v in next, getconnections(obj.Changed) do
				v:Disable()
			end
		end
		if root then dothing(root) end
		if torso then dothing(torso) end
	end,
	antihumcheck = function() -- can interfere with looping walkspeed
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		for i, v in next, getconnections(hum.Changed) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("WalkSpeed")) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("JumpPower")) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("HipHeight")) do
			v:Disable()
		end
		for i, v in next, getconnections(hum:GetPropertyChangedSignal("JumpHeight")) do
			v:Disable()
		end
	end,
	setnoclip = function(bool)
		if not bool then
			if noclipconn then
				noclipconn:Disconnect()
			end
			getgenv().noclipconn = nil
			return
		end
		getgenv().noclipconn = noclipconn or game:GetService("RunService").Stepped:Connect(function()
			pcall(function()
				for i, v in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
					if v:IsA("BasePart") then v.CanCollide = false end
				end
			end)
		end)
	end,
	setws = function(int, loopHum)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum and loopHum then
			if getgenv().wsloop then
				getgenv().wsloop:Disconnect()
			end
			getgenv().wsloop = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
				hum.WalkSpeed = int
			end)
		end
		hum.WalkSpeed = int
	end,
	setjp = function(int, loopHum)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum and loopHum then
			if getgenv().jploop then
				getgenv().jploop:Disconnect()
			end
			getgenv().jploop = hum:GetPropertyChangedSignal("JumpPower"):Connect(function()
				hum.JumpPower = int
			end)
		end
		hum.JumpPower = int
	end,
	setjpenabled = function(bool)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum then hum.UseJumpPower = bool end
	end,
	sethh = function(int)
		local hum = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
		if hum then hum.HipHeight = int end
	end,
	setgrav = function(int)
		workspace.Gravity = int
	end,
	loadiy = function()
		return loadstring(game:HttpGet(('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'),true))()
	end,
	loadcmdx = function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source", true))()
	end,
	loaddex = function() -- dark dex v3 is broken on fluxus so i decided to use babyhamsta's instead
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/BypassedDarkDexV3.lua", true))()
	end,
	loadss = function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/78n/SimpleSpy/main/SimpleSpySource.lua"))()
	end,
	loadv4 = function()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/NewMainScript.lua", true))()
	end,
	rj = function()
		game:GetService("TeleportService"):Teleport(game.PlaceId)
	end,
}
europa["getcoresecure"] = europa.getcs
europa["checkvariable"] = europa.checkvar
europa["getrealhidden"] = europa.getrh
europa["getmemory"] = europa.getmem
europa["getmemorytag"] = europa.getmemtag
europa["hookmemory"] = europa.hookmem
europa["getremotes"] = europa.getrems
europa["isnilinstance"] = europa.isnil
europa["setmemoryinflation"] = europa.setmeminflation
europa["setmemorytaginflation"] = europa.setmemtaginflation
europa["disconnect"] = europa.disconn
europa["securedisconnect"] = europa.securedisconn
europa["hookfireserver"] = europa.hookfs
europa["hookinvokeserver"] = europa.hookis
europa["hookgetservice"] = europa.hookgs
europa["hookinstancecount"] = europa.hookinscount
europa["waithookfunction"] = europa.waithookfunc
europa["antihumanoidcheck"] = europa.antihumcheck
europa["setwalkspeed"] = europa.setws
europa["setjumppower"] = europa.setjp
europa["sethipheight"] = europa.sethh
europa["setmaxslopeangle"] = europa.setmsa
europa["setgravity"] = europa.setgrav
europa["setjumppowerenabled"] = europa.setjpenabled
europa["loadinfiniteyield"] = europa.loadiy
europa["loadsimplespy"] = europa.loadss
europa["loadvapev4"] = europa.loadv4
europa["rejoin"] = europa.rj

for i, v in europa do
	getgenv()[i] = v
end
